#include <windows.h>
#include <stdio.h>

int main(int argc, char* argv[]) {

	DWORD PID = NULL, TID=NULL;
	HMODULE hKernel32 = NULL;
	HANDLE hProcess = NULL, hModule = NULL, hThread = NULL;
	LPVOID rBuffer = NULL;


	wchar_t dllPath[MAX_PATH] = L"C:\\Users\\luan\\source\\repos\\randomDLL.dll";
	size_t dllPathSize = sizeof(dllPath);

	if (argc < 2) {
		printf("invalid paremeters\n");
		return EXIT_FAILURE;
	}

	PID = atoi(argv[1]);

	printf("trying to get a handle to the process (%ld)\n", PID);

	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);

	if (hProcess == NULL) {
		printf("Failed to get handle to the process, error: %ld", GetLastError());
		return EXIT_FAILURE;
	}


	printf("got handle to the process (%ld)\n\\---0x%p", PID, hProcess);

	rBuffer = VirtualAllocEx(hProcess, NULL, dllPathSize, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);
	

	if (rBuffer == NULL) {
		printf("Failed to create buffer on the process, error: %ld", GetLastError());
		return EXIT_FAILURE;
	}
	printf("Allocated buffer to process memory w/ PAGE_READWRITE permissions\n");

	WriteProcessMemory(hProcess, rBuffer, dllPath, dllPathSize, NULL);
	printf("wrote [%S] to process memory\n", dllPath);

	hKernel32 = GetModuleHandleW(L"Kernel32");

	if (hKernel32 == NULL) {
		printf("Failed to get handle to Kernel32.dll, error: %ld", GetLastError());
		return EXIT_FAILURE;
	}

	printf("Got handle to Kernel32.dll\n\\---0x%p\n", hKernel32);

	LPTHREAD_START_ROUTINE startThis = (LPTHREAD_START_ROUTINE)GetProcAddress(hKernel32, "LoadLibraryW");
	printf("got the address of LoadLibraryW()\n\\---0x%p\n", startThis);

	hThread = CreateRemoteThread(hProcess, NULL, 0, startThis, rBuffer, 0, &TID);
	
	if (hThread == NULL) {
		printf("Failed to get handle to thread, error: %ld", GetLastError());
		return EXIT_FAILURE;
	}

	printf("got handle to the newly-created thread (%ld)\n\\---0x%p", TID, hThread);
	WaitForSingleObject(hThread, INFINITE);


	CloseHandle(hThread);
	CloseHandle(hProcess);



	return EXIT_SUCCESS;


}